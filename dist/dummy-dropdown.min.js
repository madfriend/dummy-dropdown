var DummyDropdown =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["extendObject"] = extendObject;
/* harmony export (immutable) */ __webpack_exports__["filterNodesByTag"] = filterNodesByTag;
/* harmony export (immutable) */ __webpack_exports__["parseOptionNodes"] = parseOptionNodes;
/* harmony export (immutable) */ __webpack_exports__["debounce"] = debounce;
/* harmony export (immutable) */ __webpack_exports__["hasClass"] = hasClass;
/* harmony export (immutable) */ __webpack_exports__["anyParentHasClass"] = anyParentHasClass;
/* harmony export (immutable) */ __webpack_exports__["findParentOrSelfWithClass"] = findParentOrSelfWithClass;
/* harmony export (immutable) */ __webpack_exports__["removeClass"] = removeClass;
/* harmony export (immutable) */ __webpack_exports__["checkInView"] = checkInView;
/* harmony export (immutable) */ __webpack_exports__["ajaxGetJSON"] = ajaxGetJSON;
/* harmony export (immutable) */ __webpack_exports__["arrayUnique"] = arrayUnique;
function extendObject(A, B) {
   // Make a copy of A (C) and update keys: C.key = B.key ? B.key : A.key;
   //
   // This function should be used only for plain, one-dimension objects
   // where values are simple primitives (bool, int, str).
   var C = {};
   for (var key in A) {
      if (!A.hasOwnProperty(key)) continue;
      C[key] = A[key];
      if (B.hasOwnProperty(key)) C[key] = B[key];
   }
   return C;
} // end extendObject

function filterNodesByTag(nodes, tag) {
   var results = [];
   for (var i = 0; i < nodes.length; i++) {
      if (nodes[i].tagName.toLowerCase() == tag)
         results.push(nodes[i]);
   };
   return results;
} // end filterNodesByTag

function parseOptionNodes(options) {
   var results = [];

   for (var i = 0; i < options.length; i++) {
      var o = options[i];
      results.push({
         'value': o.value,
         'img':   o.getAttribute('data-img') || false,
         'desc':  o.getAttribute('data-desc') || '',
         'text':  o.text
      });
   }
   return results;
}; // end parseOptionNodes

function debounce(func, wait, immediate) {
   var timeout;
   return function() {
      var context = this, args = arguments;
      var later = function() {
         timeout = null;
         if (!immediate) func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) func.apply(context, args);
   };
}; // end debounce

function hasClass(node, cls) {
   var className = ' ' + cls + ' ';
   return ((' ' + node.className + ' ').replace(/[\n\t]/g, ' ').indexOf(className) > -1);
} // end hasClass

function anyParentHasClass(node, cls) {
   if (hasClass(node, cls)) return true;
   if (!node.parentNode) return false;
   return anyParentHasClass(node.parentNode, cls);
} // end anyParentHasClass

function findParentOrSelfWithClass(node, cls) {
   if (hasClass(node, cls)) return node;
   var parent = node.parentNode;
   if (!parent) return false;
   if (hasClass(parent, cls)) return parent;
   return findParentOrSelfWithClass(parent, cls);
} // end findParentWithClass

function removeClass(node, cls) {
   var r = new RegExp('\\b' + cls + '\\b', 'g');
   node.className = node.className.replace(r, ' ');
} // add removeClass

function checkInView(container, element) {
   // Get container properties
   var cTop = container.scrollTop;
   var cBottom = cTop + container.clientHeight;

   // Get element properties
   var eTop = element.offsetTop;
   var eBottom = eTop + element.clientHeight;

   // Check if in view
   var is = (eTop >= cTop && eBottom <= cBottom);
   return is;
} // end checkInView

function ajaxGetJSON(url, callback) {
   var xhr;
   var callbackFired = false;

   try {
      xhr = new(this.XMLHttpRequest || ActiveXObject)('MSXML2.XMLHTTP.3.0');
      xhr.open('GET', url, 1);
      xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
      xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
      xhr.onreadystatechange = function() {
         xhr.readyState > 3 && callback && callback(JSON.parse(xhr.responseText), xhr);
         callbackFired = true;
      };

      xhr.send();
   } catch (e) {
      console.log(e);
      // try jsonp instead
      if (callbackFired) return;

      var script = document.createElement('script');
      var name = 'f' + Math.random().toString(36).substr(2, 5);
      window[name] = callback;

      script.src = url + '&callback=' + name;
      document.body.appendChild(script);
   }
} // end ajaxGet

function arrayUnique(array) {
   var keys = Object.create({});
   var out = [];
   for (var i = 0; i < array.length; i++) {
      if (keys[array[i]]) continue;
      keys[array[i]] = 1;
      out.push(array[i]);
   }
   return out;
}


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var utils = __webpack_require__(0);
var utilsStr = __webpack_require__(5);
var HTMLLayer = __webpack_require__(4);


function Dropdown(selectNode, options) {
   this._state = {};
   this._initState(selectNode, options);
   this._timer = false;
   this._html = new HTMLLayer(this._state);
   this._wrapper = this._html.initLayout(selectNode);

   this.render();
   this._bindEventListeners();
};

var kbdDebounceTimeout = 100;
var maxResultsLen = 30;

// Public API //////////////////////////////////////////////////////////////
Dropdown.prototype.getValue = function() {
   return this._state.value || [];
};

Dropdown.prototype.setValue = function(v) {
   this._state.value = v;
};

Dropdown.prototype.val = function(v) {
   return v ? this.setValue(v) : this.getValue();
};

Dropdown.prototype.open = function() {
   if (this._state.isOpen) return true;

   this._state.isOpen = true;
   this._state.isFocused = true;
   this._wrapper.focus();
   this.render();
   return true;
};

Dropdown.prototype.close = function() {
   if (!this._state.isOpen) return true;

   this._state.isOpen = false;
   this._state.isFocused = false;
   this._state.searchQuery = '';
   this._state.visibleItems = this._initVisibleItems();

   this._wrapper.blur();
   this.render();
   return true;
};

Dropdown.prototype.render = function() {
   this._html.render(this.getValue());
   var i = this._wrapper.querySelector('.dd-input');
   if (i) i.addEventListener('blur', this._handleInputBlur.bind(this));
};

// "Private" API ///////////////////////////////////////////////////////////
// Initialization methods
Dropdown.prototype._initState = function(node, options) {
   this._state.options = options;
   this._state.items = utils.parseOptionNodes(node.options);
   this._state.visibleItems = this._initVisibleItems();
   this._state.searchQuery = '';

   this._state.isOpen = false;
   this._state.isFocused = false;
   this._state.isAddingFocusOnInput = false;
   this._state.isRubbery = options.multiselect;

   this._state.value = false;
   this._state.placeholder = 'Выберите что-нибудь';

   this._searchIndex = {};
   if (options.combobox) {
      window.setTimeout(this._initSearchIndex.bind(this), 0);
   }
};

Dropdown.prototype._initVisibleItems = function() {
   if (!this._state.options.combobox && !this._state.options.multiselect) {
      return this._state.items.slice(0);
   }

   var out = [];
   var value = this.getValue();
   var found = 0;

   for (var i = 0; i < this._state.items.length; i++) {
      var item = this._state.items[i];
      if (value.indexOf(item.value) >= 0) continue;
      out.push(item);
      found++;
      if (found >= maxResultsLen) break;
   }

   return out;
};

Dropdown.prototype._initSearchIndex = function() {
   // console.time('makeSearchIndex');

   // Currently this is a very blunt structure.
   // If performance of this piece of code would be disappointing,
   // one might try to rewrite this structure (and whole search) to be
   // more efficient.
   //
   // For example, we can make [token -> (value_id, span)] map where
   // keys are all possible tokens in all possible layouts and
   // value_id is the sentence which provided the token.
   //
   // Then we can be build a prefix tree for all tokens
   // where each level of tree has special <END> key
   // containing a list references of (value_id, span).

   var items = this._state.items;
   var index = this._searchIndex;

   for (var i = 0; i < items.length; i++) {
      index[items[i].value] = [];
      var all_ngrams = utilsStr.allPossibleTokens(items[i].value);
      for (var j = 0; j < all_ngrams.length; j++) {
         index[items[i].value] = index[items[i].value].concat(
            utilsStr.allKeyboardLayoutInvariants(all_ngrams[j].toLowerCase()));
      }
   };
   // console.timeEnd('makeSearchIndex');
};

// Event API: bind + all event handlers.
Dropdown.prototype._bindEventListeners = function() {
   this._wrapper.addEventListener('mousedown', this._handleClick.bind(this));
   this._wrapper.addEventListener('keydown', this._handleSpecialKeys.bind(this));
   this._wrapper.addEventListener('keyup', utils.debounce(
      this._handleTextInput.bind(this), kbdDebounceTimeout));

   this._wrapper.addEventListener('focus', this._handleFocus.bind(this));
   this._wrapper.addEventListener('blur', this._handleFocusout.bind(this));

   this._wrapper.addEventListener('mouseover', this._handleMouseover.bind(this));
};

Dropdown.prototype._handleFocus = function(event) {
   // console.log('focus', event);
   if (this._state.isFocused) {
      return false;
   }

   this._state.isFocused = true;
   this._state.isOpen = true;
   this.render();

   if (this._state.options.combobox) this._focusOnInput();

   return false;
};

Dropdown.prototype._handleMouseover = function(event) {
   var tgt = event.target;
   if (utils.anyParentHasClass(tgt, 'dd-item')) {
      tgt = utils.findParentOrSelfWithClass(tgt, 'dd-item');
      event.stopPropagation();
      if (utils.hasClass(tgt, 'dd-hover')) return false;
      var other = this._wrapper.querySelectorAll('.dd-hover');

      for (var i = 0; i < other.length; i++) {
         utils.removeClass(other[i], 'dd-hover');
      }

      tgt.className += ' dd-hover';
   }
};

Dropdown.prototype._handleFocusout = function(event) {
   // console.log('blur - parent', this._state.isAddingFocusOnInput);
   if (this._state.isAddingFocusOnInput) return false;

   event.stopPropagation();
   this._state.isFocused = false;
   this.close();
   return false;
};

Dropdown.prototype._handleDelete = function(event) {
   console.log('handleDelete', event.target, event.target.getAttribute('data-value'));
   var del = event.target.getAttribute('data-value');
   var values = this.getValue();
   var index = values.indexOf(del);
   if (index < 0) return false;

   values.splice(index, 1);
   this.setValue(values);

   if (this._state.isOpen) {
      this.close();
   }
   else {
      this._state.visibleItems = this._initVisibleItems();
      this.render();
   }

   return false;
};

Dropdown.prototype._handleClick = function(event) {
   // console.log('click', event);
   event.stopPropagation();
   var tgt = event.target;

   if (utils.anyParentHasClass(tgt, 'dd-item')) {
      tgt = utils.findParentOrSelfWithClass(tgt, 'dd-item');
      if (utils.hasClass(tgt, 'dd-selected')) return false;

      if (!this._state.options.multiselect) {
         this.setValue([tgt.getAttribute('data-value')]);
      } else {
         var v = this.getValue();
         this.setValue(v.concat([tgt.getAttribute('data-value')]));
      }
      this.close();
      return false;
   }

   if (utils.hasClass(tgt, 'dd-delete')) {
      event.preventDefault();
      this._handleDelete(event);
      return false;
   }

   if (utils.hasClass(tgt, 'dd-input')) {
      return false;
      // this._focusOnInput();
   }

   if (utils.hasClass(tgt, 'dd-arrow')) {
      if (this._state.isOpen) return this.close();
   }

   return setTimeout(function() {
      // console.log('setting focus to parent');
      if (!this._state.isFocused) this._wrapper.focus();
   }.bind(this), 10);
};

Dropdown.prototype._handleInputBlur = function(event) {
   // console.log('blur - input');
   this._state.isFocused = false;
   this.close();
   return false;
};

Dropdown.prototype._handleSpecialKeys = function(event) {
   var specialCodes = [38, 40, 13, 27]; // up, down, enter, esc

   if (specialCodes.indexOf(event.keyCode) >= 0) {
      event.stopImmediatePropagation();
      event.preventDefault();
   } else {
      return false;
   }

   var current = this._wrapper.querySelector('.dd-hover');
   var prev = false;
   var next = false;

   if (current) {
      prev = current.previousElementSibling;
      next = current.nextElementSibling;
   }
   else {
      next = this._wrapper.querySelector('.dd-item');
   }

   switch (event.keyCode) {
      case 38: // up
         if (!prev) return false;
         prev.className += ' dd-hover';
         if (!utils.checkInView(prev.parentNode, prev))
            prev.parentNode.scrollTop = prev.offsetTop;

         if (current) utils.removeClass(current, 'dd-hover');
         return false;
         break;

      case 40: // down
         if (!next) return false;
         next.className += ' dd-hover';

         if (!utils.checkInView(next.parentNode, next)) {
            next.parentNode.scrollTop =
               (next.offsetTop - next.parentNode.clientHeight + next.clientHeight);
         }

         if (current) utils.removeClass(current, 'dd-hover');
         return false;
         break;

      case 13: // enter
         var active = this._wrapper.querySelector('.dd-hover');
         if (!active) return false;
         if (utils.hasClass(active, 'dd-selected')) return false;

         if (!this._state.options.multiselect) {
            this.setValue([active.getAttribute('data-value')]);
         } else {
            var v = this.getValue();
            this.setValue(v.concat([active.getAttribute('data-value')]));
         }

         this.close();
         return false;
         break;

      case 27: // esc
         this.close();
         break;

      default:
         break;
   }
};

Dropdown.prototype._handleTextInput = function(event) {
   if (!this._state.isOpen || !this._state.options.combobox) return false;
   var specialCodes = [38, 40, 13, 27]; // up, down, enter, esc
   if (specialCodes.indexOf(event.keyCode) >= 0) return false;

   var input = this._wrapper.querySelector('.dd-input');
   var val = input.value;
   if (val === this._state.searchQuery) return false;

   window.clearTimeout(this._timer);

   this._timer = window.setTimeout(function() {
         this._state.searchQuery = val;
         this._updateVisibleItems(this._html.renderTail.bind(this._html));
      }.bind(this), 0);

   return false;
};

// Various pieces of search API
Dropdown.prototype._updateVisibleItems = function(callback) {
   // console.time('updateVisible');
   var query = this._state.searchQuery;
   var currentValue = this.getValue();

   callback = callback || function() {};

   function filterItems(whitelist) {
      var l = 0;
      var filtered = [];

      for (var i = 0; i < this._state.items.length; i++) {
         var item = this._state.items[i];
         if (currentValue.indexOf(item.value) >= 0) continue;
         if (whitelist.indexOf(item.value) >= 0 || this._matchesQuery(item)) {
            l++;
            filtered.push(item);
         }
         if (l >= maxResultsLen) break;
      };
      this._state.visibleItems = filtered;
   };

   filterItems = filterItems.bind(this);

   if (!query) {
      this._state.visibleItems = this._initVisibleItems();
      callback();
      return true;
   }

   if (this._state.options.combobox &&
       this._state.options.ajaxSearchURL) {

      this._searchItemsOnServer(function(results) {
         filterItems(results);
         callback();
      });

   }
   else {
      filterItems([]);
      callback();
   }

   // console.timeEnd('updateVisible');
   return true;
};

Dropdown.prototype._searchItemsOnServer = function(callback) {
   var queries = utilsStr.allKeyboardLayoutInvariants(this._state.searchQuery);
   var qs = [];
   for (var i = 0; i < queries.length; i++) {
      qs.push('query=' + encodeURIComponent(queries[i]));
   }

   utils.ajaxGetJSON(this._state.options.ajaxSearchURL + '?' + qs.join('&'),
      callback);
};

Dropdown.prototype._matchesQuery = function(item) {
   var q = this._state.searchQuery;
   var tests = this._searchIndex[item.value] || item.value.split(/\s+/);
   for (var i = 0; i < tests.length; i++) {
      if (utilsStr.startsWith(tests[i], q.toLowerCase())) return true;
   };
   return false;
};

Dropdown.prototype._focusOnInput = function() {
   var i = this._wrapper.querySelector('.dd-input');
   this._state.isAddingFocusOnInput = true;
   setTimeout(function() {
      // console.log('setting focus on input');
      i.focus();
      setTimeout(function() { // IE9..
         this._state.isAddingFocusOnInput = false;
      }.bind(this), 10);

      var v = i.value;
      i.value = '';
      i.value = v;

   }.bind(this), 10);

   return true;
};

module.exports = Dropdown;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(6);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(8)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../../../node_modules/css-loader/index.js!./dummy-dropdown.css", function() {
			var newContent = require("!!../../../../node_modules/css-loader/index.js!./dummy-dropdown.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var utils = __webpack_require__(0);
var Dropdown = __webpack_require__(1);

__webpack_require__(2);


if (typeof console === "undefined" ||
    typeof _DROPDOWN_DEBUG === "undefined" ||
    !_DROPDOWN_DEBUG) {
  var console = {log: function() {}, time: function() {}, timeEnd: function() {}};
}


function DropdownCollection(selector, options) {
   if (typeof options != 'object') options = {};
   var defaults = {
      multiselect: false,
      combobox: false,
      withImages: false,
      withDesc: false,
      ajaxSearchURL: false
   };

   var _options = utils.extendObject(defaults, options);
   this._options = _options;

   var results = [];
   try {
      results = document.querySelectorAll(selector);
   } catch (e) {
      console.log('Check your selector. ' + e);
   }

   var _nodes = utils.filterNodesByTag(results, 'select');
   this.dropdowns = [];
   for (var i = 0; i < _nodes.length; i++) {
      this.dropdowns.push(new Dropdown(_nodes[i], _options));
   };
}

DropdownCollection.prototype.get = function(i) {
   return this.dropdowns[i || 0];
};

module.exports = DropdownCollection;


/***/ }),
/* 4 */
/***/ (function(module, exports) {

function HTMLLayer(state) {
   this._state = state;
   this._wrapperWidth = 0;
   this._arrowWidth = 25;
}

HTMLLayer.prototype.initLayout = function(node) {
   var wrapper = document.createElement('div');
   wrapper.tabIndex = 0;

   wrapper.className = 'dd-n dd-wrapper dd-hidden';
   wrapper.style.maxWidth = node.offsetWidth + 'px';

   this._wrapperWidth = node.offsetWidth;

   node.className += ' dd-hidden';
   node.tabIndex = -1;
   node.parentNode.insertBefore(wrapper, node);
   this._wrapper = wrapper;

   return wrapper;
};

HTMLLayer.prototype.render = function(currentValue) {
   // console.time('render');
   var wrapper = this._wrapper;
   wrapper.style.display = 'none';

   var markup = '';
   markup += (this._state.options.combobox ?
      this.comboHeadHTML(currentValue) : this.plainHeadHTML(currentValue));

   markup += this.listContentsHTML(currentValue);

   wrapper.innerHTML = markup;
   // console.timeEnd('render');

   wrapper.className = 'dd-n dd-wrapper ' +
      (this._state.isFocused ? ' dd-focused' : '') +
      (this._state.isRubbery ? ' dd-rubbery' : '');
}

HTMLLayer.prototype.renderTail = function(currentValue) {
   // console.time('renderTail');
   var btm = this._wrapper.querySelector('.dd-bottom');
   btm.innerHTML = this.listContentsHTML(currentValue, false);
   // console.timeEnd('renderTail');
};

HTMLLayer.prototype.listContentsHTML = function(currentValue, asOuterHTML) {
   if (typeof asOuterHTML === 'undefined') asOuterHTML = true;

   var contents = '';

   if (this._state.isOpen && this._state.visibleItems.length > 0) {
      var item, markup;
      var value = currentValue;

      var foundFirstActive = false;
      for (var i = 0; i < this._state.visibleItems.length; i++) {
         item = this._state.visibleItems[i];
         var cls = '';
         var selected = value.indexOf(item.value) > -1;

         if (!foundFirstActive && !selected) {
            cls = 'dd-hover';
            foundFirstActive = true;
         }
         if (selected) cls = 'dd-selected';

         markup = this.listItemHTML(item, cls);
         contents += markup;
      }
   }

   if (this._state.isOpen && this._state.visibleItems.length === 0) {
      contents = '<div class="dd-n dd-not-found">Ничего не найдено</div>';
   }

   if (!asOuterHTML) return contents;

   var cls = this._state.isOpen ? '' : 'dd-hidden';
   return '<div class="dd-n dd-bottom ' + cls + '">' + contents + '</div>';
};

HTMLLayer.prototype.listItemHTML = function(item, cls) {
   var tpl = '';
   var contents = '';

   if (this._state.options.withImages && this._state.options.withDesc) {
      tpl = '<div class="dd-n dd-tbl">' +
               '<div class="dd-n dd-img dd-left">' +
                  (item.img ? '<div class="dd-n dd-img"><img src="{{src}}"/></div>' : '') +
               '</div>' +
               '<div class="dd-n dd-right">' +
                  '<div class="dd-n dd-t">{{text}}</div>' +
                  '<div class="dd-n dd-desc">{{desc}}</div>' +
               '</div>' +
            '</div>';
   }

   else if (this._state.options.withImages && !this._state.options.withDesc) {
      tpl = '<div class="dd-n dd-tbl">' +
               '<div class="dd-n dd-img dd-left">' +
               (item.img ? '<div class="dd-n dd-img"><img src="{{src}}"/></div>' : '') +
               '</div>' +
               '<div class="dd-n dd-right">' +
                  '<div class="dd-n dd-t">{{text}}</div>' +
               '</div>' +
            '</div>';
   }

   else if (this._state.options.withDesc) {
      tpl = '<div class="dd-n">' +
               '<div class="dd-n dd-t">{{text}}</div>' +
               '<div class="dd-n dd-desc">{{desc}}</div>' +
            '</div>';
   }
   else {
      tpl = '<div class="dd-n">' +
               '<div class="dd-n dd-t">{{text}}</div>' +
            '</div>';
   }

   contents = tpl.replace('{{text}}', item.text)
                 .replace('{{desc}}', item.desc)
                 .replace('{{src}}', item.img);

   return '<div class="dd-n dd-item ' + cls + '" data-value="' + item.value + '">' +
      contents + '</div>';
};

HTMLLayer.prototype.comboHeadHTML = function(currentValue) {
   var value = currentValue;
   var width = this._wrapperWidth - this._arrowWidth;

   var html = '';
   if (this._state.options.multiselect) {
      // if multiple selections are allowed,
      // we have (current values or placeholder) + input if isOpen
      if (this._state.isOpen) {
         html += (value.length > 0 ? this.renderMultiValueHTML(value) : '');
         html += '<input type="text" tabindex="-1" class="dd-input" placeholder="' +
               this._state.placeholder + '"/>';
      }
      else {
         html += (value.length > 0 ? this.renderMultiValueHTML(value) :
            this._state.placeholder);
      }
   }
   else {
      // if only one selection is allowed,
      // we have an input ifOpen else value/placeholder
      if (this._state.isOpen) {
         html += '<input type="text" tabindex="-1" class="dd-input" ' +
            'placeholder="' + this._state.placeholder + '" ' +
            (value.length > 0 ? 'value="' + value[0] + '"' : '') + '/>';
      }
      else {
         html += (value.length > 0 ? value[0] : this._state.placeholder);
      }
   }

   var contents = '<div class="dd-n dd-value" style="max-width: ' + width + 'px">' +
      html + '</div>' + '<div class="dd-n dd-arrow dd-' +
      (this._state.isOpen ? 'up': 'down') + '"></div>';

   return '<div class="dd-n dd-head">' + contents + '</div>';
};

HTMLLayer.prototype.plainHeadHTML = function(currentValue) {
   var value = currentValue;
   var width = this._wrapperWidth - this._arrowWidth;

   if (value.length > 0 && this._state.options.multiselect) {
      value = this.renderMultiValueHTML(value);
   }
   else if (value.length === 0) {
      value = this._state.placeholder;
   }
   else {
      value = value[0];
   }

   var isOpen = this._state.isOpen;

   var contents = '<div class="dd-n dd-value" style="max-width: ' + width + 'px">' +
      value + '</div>' +
      '<div class="dd-n dd-arrow dd-' + (isOpen ? 'up': 'down') + '"></div>';

   return '<div class="dd-n dd-head">' + contents + '</div>';
};

HTMLLayer.prototype.renderMultiValueHTML = function(currentValue) {
   var contents = '';
   for (var i = 0; i < currentValue.length; i++) {
      var v = currentValue[i];
      contents += '<div class="dd-n dd-v" data-value="' + v + '">' +
         '<div class="dd-n dd-text">' + v + '</div>' +
         '<div class="dd-n dd-delete" data-value="' + v +
         '">&#10005;</div></div>';
   }
   return contents;
};

module.exports = HTMLLayer;


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["startsWith"] = startsWith;
/* harmony export (immutable) */ __webpack_exports__["allKeyboardLayoutInvariants"] = allKeyboardLayoutInvariants;
/* harmony export (immutable) */ __webpack_exports__["swapLayout"] = swapLayout;
/* harmony export (immutable) */ __webpack_exports__["translit"] = translit;
/* harmony export (immutable) */ __webpack_exports__["allPossibleTokens"] = allPossibleTokens;
var arrayUnique = __webpack_require__(0).arrayUnique;


function startsWith(haystack, needle) {
   return haystack.lastIndexOf(needle, 0) === 0;
} // end startsWith

function allKeyboardLayoutInvariants(word) {
   return [word, swapLayout(word),
      translit(word), swapLayout(translit(word))];
} // end allKeyboardVariants

var enru = [
   'qй', 'wц', 'eу', 'rк', 'tе', 'yн', 'uг', 'iш', 'oщ', 'pз', '[х', '{Х',
   ']ъ', '}Ъ', '|/', '`ё', '~Ё', 'aф', 'sы', 'dв', 'fа', 'gп', 'hр', 'jо',
   'kл', 'lд', ';ж', ':Ж', "'э", '"Э', 'zя', 'xч', 'cс', 'vм', 'bи', 'nт',
   'mь', ',б', '<Б', '.ю', '>Ю', '/.', '?, ', '@"', '#№', '$;', '^:', '&?'
];
var layoutMap = {};
for (var i = 0; i < enru.length; i++) {
   layoutMap[enru[i][0]] = enru[i][1];
   layoutMap[enru[i][1]] = enru[i][0];
};

function swapLayout(word) {
   var out = '';
   for (var i = 0; i < word.length; i++)
      out += (layoutMap[word[i]] || word[i]);
   return out;
}

var translitMap = [
   'щ ш ч ц ю я ё ж ъ ы э а б в г д е з и й к л м н о п р с т у ф х ь'.split(' '),
   "shh sh ch cz yu ya yo zh `` y' e` a b v g d e z i j k l m n o p r s t u f x `".split(' ')
];

function translit(word) {
   // detect lang
   var ruMatches = 0;
   var enMatches = 0;

   for (var i = 0; i < translitMap[0].length; i++)
      ruMatches += (word.indexOf(translitMap[0][i]) >= 0 ? 1 : 0);
   for (var j = 0; j < translitMap[1].length; j++)
      enMatches += (word.indexOf(translitMap[1][j]) >= 0 ? 1 : 0);

   var engToRus = (enMatches > ruMatches);
   var rus = translitMap[0], eng = translitMap[1];

   for(var x = 0; x < rus.length; x++) {
      word = word.split(engToRus ? eng[x] : rus[x]).join(engToRus ? rus[x] : eng[x]);
      word = word.split(engToRus ? eng[x].toUpperCase() : rus[x].toUpperCase()).join(engToRus ? rus[x].toUpperCase() : eng[x].toUpperCase());
   }
   return word;
} // end translit

function allPossibleTokens(sentence) {
   // aka all possible n-grams, each joined by space
   var out = [];
   var words = sentence.split(/\s+/);
   var words2 = sentence.split(/\W*\s+\W*/);

   for (var window = 2; window <= words.length; window++) {
      for (var offset = 0; offset <= words.length - window; offset++) {
         out = out.concat(words.slice(offset, offset+window).join(' '));
         out = out.concat(words2.slice(offset, offset+window).join(' '));
      }
   }

   out = words2.concat(words.concat(out));
   return arrayUnique(out);
} // allPossibleTokens


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(7)(undefined);
// imports


// module
exports.push([module.i, ".dd-n {\n   width: 100%;\n   min-width: 0;\n   max-width: initial;\n   height: auto;\n   min-height: 0;\n   max-height: initial;\n   padding: 0;\n   margin: 0;\n}\n\n.dd-wrapper {\n   display: inline-block !important;\n   position: relative;\n   height: 25px;\n   line-height: 25px;\n   font-size: 13px;\n   color: #444;\n   min-width: 100px;\n   box-sizing: content-box;\n   border: solid 1px #ccc;\n   border-radius: 3px;\n   background-color: #fefefe;\n   vertical-align: bottom;\n   margin-right: 5px;\n   z-index: 1;\n}\n\n.dd-wrapper.dd-rubbery,\n.dd-wrapper.dd-rubbery .dd-head,\n.dd-wrapper.dd-rubbery .dd-value {\n   height: auto;\n   min-height: 25px;\n}\n\n.dd-hidden {\n   display: none;\n}\n\n.dd-head {\n   height: 25px;\n}\n\n.dd-wrapper:focus {\n   outline: 0 none;\n   outline: 0px solid #fff;\n   -o-outline: 0px solid #fff;\n   outline-width: 0;\n   outline-color: rgba(0, 0, 0, 0);\n   outline-offset: -2px;\n}\n\n.dd-wrapper.dd-focused {\n   border: 1px solid #4D90FE;\n   /*-webkit-box-shadow: 0px 0px 5px  #4D90FE;\n   box-shadow: 0px 0px 5px  #4D90FE;*/\n}\n\n.dd-wrapper.dd-focused .dd-bottom {\n   border: 1px solid #4D90FE;\n   border-top: none;\n   /*-webkit-box-shadow: 0px 0px 5px  #4D90FE;\n   box-shadow: 0px 0px 5px  #4D90FE;*/\n}\n\n.dd-head .dd-value {\n   display: inline-block;\n   overflow: hidden;\n   min-width: 75px;\n   height: 25px;\n   line-height: 25px;\n   vertical-align: top;\n   box-sizing: border-box;\n   padding: 0px 6px;\n   cursor: pointer;\n   clear: both;\n}\n\n.dd-head .dd-arrow {\n   display: inline-block;\n   position: absolute;\n   top: 0;\n   right: 0;\n   z-index: 100;\n   font-size: 16px;\n   width: 25px;\n   height: 25px;\n   cursor: pointer;\n\n/*   -webkit-transition: all 0.2s;\n   -moz-transition: all 0.2s;\n   transition: all 0.2s;*/\n}\n\n.dd-arrow:after {\n   height: 6px;\n   width: 6px;\n   content: '';\n   display: block;\n   position: absolute;\n}\n\n.dd-arrow.dd-down:after {\n   left: 8px;\n   top: 8px;\n\n   border-bottom: solid 1px #999;\n   border-right: solid 1px #999;\n\n   transform-origin: center center;\n\n   -o-transform: rotate(45deg);\n   -moz-transform: rotate(45deg);\n   -ms-transform: rotate(45deg);\n   -webkit-transform: rotate(45deg);\n   transform: rotate(45deg);\n}\n\n.dd-arrow.dd-up:after {\n   bottom: 7px;\n   left: 8px;\n\n   border-top: solid 1px #999;\n   border-right: solid 1px #999;\n\n   transform-origin: center center;\n\n   -o-transform: rotate(-45deg);\n   -moz-transform: rotate(-45deg);\n   -ms-transform: rotate(-45deg);\n   -webkit-transform: rotate(-45deg);\n   transform: rotate(-45deg);\n}\n\n.dd-wrapper .dd-bottom {\n   background-color: #fefefe;\n   z-index: 101;\n   position: absolute;\n   margin-top: -1px; /* to overlap dd-head border */\n   left: -1px; /* -1 because dd-bottom has left-border */\n   border-radius: 3px;\n   border: solid 1px #ccc;\n   border-top-left-radius: 0px;\n   border-top-right-radius: 0px;\n   border-top: none;\n   width: 100%;\n   max-height: 200px;\n   overflow-y: scroll;\n   overflow-x: hidden;\n   box-sizing: content-box;\n}\n\n.dd-wrapper .dd-bottom:empty {\n   height: 0;\n   padding: 0;\n}\n\n.dd-wrapper .dd-item {\n   padding: 0px 6px;\n   cursor: pointer;\n   min-height: 25px;\n   line-height: 25px;\n}\n\n.dd-wrapper .dd-item.dd-hover {\n   background-color: #f3f3f3;\n}\n\n.dd-wrapper .dd-item.dd-selected {\n   background-color: #dae2ea;\n   cursor: default;\n}\n\n.dd-v {\n   float: left;\n   width: auto;\n   background-color: #6285af;\n   margin-right: 2.5px;\n   margin-top: 2.5px;\n   color: white;\n   padding: 0px 6px;\n   border-radius: 3px;\n   height: 20px;\n   line-height: 20px;\n   vertical-align: middle;\n   box-sizing: border-box;\n   font-size: 0;\n   overflow: hidden;\n   position: relative;\n   left: -3px;\n}\n\n.dd-v:last-child {\n   margin-bottom: 2.5px;\n}\n\n.dd-v .dd-delete:hover {\n   color: white;\n}\n\n.dd-v .dd-text, .dd-v .dd-delete {\n   font-size: 13px;\n   display: inline-block;\n   width: auto;\n   line-height: 20px;\n   height: 20px;\n   vertical-align: middle;\n}\n\n.dd-v .dd-delete {\n   box-sizing: border-box;\n   margin-left: 6px;\n   color: rgba(255, 255, 255, 0.3);\n   -webkit-transition: all 0.2s;\n   transition: all 0.2s;\n}\n\n.dd-tbl {\n   display: table;\n   padding-bottom: 5px;\n}\n\n.dd-tbl .dd-left, .dd-tbl .dd-right {\n   display: table-cell;\n   vertical-align: top;\n}\n\n.dd-tbl .dd-right {\n   width: auto;\n   height: 40px;\n}\n\n.dd-tbl .dd-left {\n   width: 35px;\n   height: 40px;\n   vertical-align: middle;\n}\n\n.dd-img img {\n   height: 30px;\n}\n\n.dd-img {\n   height: 30px;\n   width: 30px;\n   /*border-radius: 15px;*/\n   overflow: hidden;\n   text-align: center;\n}\n\n.dd-hidden img {\n   display: none;\n}\n\n.dd-desc {\n   color: #999;\n   font-size: 11px;\n   height: 15px;\n   line-height: 15px;\n   vertical-align: center;\n}\n\n.dd-text {\n   height: 25px;\n}\n\n.dd-input {\n   border: none;\n   background: none;\n   margin: 0;\n   height: 25px;\n   line-height: 25px;\n   display: block;\n   font-size: 13px;\n   padding: 0;\n   font-family: -apple-system, BlinkMacSystemFont,\n        'Helvetica Neue', Arial, sans-serif;;\n}\n\n.dd-input:focus {\n   outline: 0 none;\n   outline: 0px solid #fff;\n   -o-outline: 0px solid #fff;\n   outline-width: 0;\n   outline-color: rgba(0, 0, 0, 0);\n   outline-offset: -2px;\n}\n\n.dd-not-found {\n   height: 25px;\n   padding: 0px 6px;\n}\n\n.dd-input:focus::-webkit-input-placeholder { color: transparent; }\n.dd-input:focus:-moz-placeholder { color:transparent; } /* FF 4-18 */\n.dd-input:focus::-moz-placeholder { color:transparent; } /* FF 19+ */\n.dd-input:focus:-ms-input-placeholder { color:transparent; } /* IE 10+ */\n", ""]);

// exports


/***/ }),
/* 7 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var stylesInDom = {},
	memoize = function(fn) {
		var memo;
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	},
	isOldIE = memoize(function() {
		// Test for IE <= 9 as proposed by Browserhacks
		// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
		// Tests for existence of standard globals is to allow style-loader 
		// to operate correctly into non-standard environments
		// @see https://github.com/webpack-contrib/style-loader/issues/177
		return window && document && document.all && !window.atob;
	}),
	getElement = (function(fn) {
		var memo = {};
		return function(selector) {
			if (typeof memo[selector] === "undefined") {
				memo[selector] = fn.call(this, selector);
			}
			return memo[selector]
		};
	})(function (styleTarget) {
		return document.querySelector(styleTarget)
	}),
	singletonElement = null,
	singletonCounter = 0,
	styleElementsInsertedAtTop = [],
	fixUrls = __webpack_require__(9);

module.exports = function(list, options) {
	if(typeof DEBUG !== "undefined" && DEBUG) {
		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};
	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (typeof options.singleton === "undefined") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (typeof options.insertInto === "undefined") options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

	var styles = listToStyles(list, options);
	addStylesToDom(styles, options);

	return function update(newList) {
		var mayRemove = [];
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			domStyle.refs--;
			mayRemove.push(domStyle);
		}
		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}
		for(var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];
			if(domStyle.refs === 0) {
				for(var j = 0; j < domStyle.parts.length; j++)
					domStyle.parts[j]();
				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom(styles, options) {
	for(var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];
		if(domStyle) {
			domStyle.refs++;
			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}
			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];
			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}
			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles(list, options) {
	var styles = [];
	var newStyles = {};
	for(var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};
		if(!newStyles[id])
			styles.push(newStyles[id] = {id: id, parts: [part]});
		else
			newStyles[id].parts.push(part);
	}
	return styles;
}

function insertStyleElement(options, styleElement) {
	var styleTarget = getElement(options.insertInto)
	if (!styleTarget) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}
	var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
	if (options.insertAt === "top") {
		if(!lastStyleElementInsertedAtTop) {
			styleTarget.insertBefore(styleElement, styleTarget.firstChild);
		} else if(lastStyleElementInsertedAtTop.nextSibling) {
			styleTarget.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			styleTarget.appendChild(styleElement);
		}
		styleElementsInsertedAtTop.push(styleElement);
	} else if (options.insertAt === "bottom") {
		styleTarget.appendChild(styleElement);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement(styleElement) {
	styleElement.parentNode.removeChild(styleElement);
	var idx = styleElementsInsertedAtTop.indexOf(styleElement);
	if(idx >= 0) {
		styleElementsInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement(options) {
	var styleElement = document.createElement("style");
	options.attrs.type = "text/css";

	attachTagAttrs(styleElement, options.attrs);
	insertStyleElement(options, styleElement);
	return styleElement;
}

function createLinkElement(options) {
	var linkElement = document.createElement("link");
	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	attachTagAttrs(linkElement, options.attrs);
	insertStyleElement(options, linkElement);
	return linkElement;
}

function attachTagAttrs(element, attrs) {
	Object.keys(attrs).forEach(function (key) {
		element.setAttribute(key, attrs[key]);
	});
}

function addStyle(obj, options) {
	var styleElement, update, remove, transformResult;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    transformResult = options.transform(obj.css);
	    
	    if (transformResult) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = transformResult;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css. 
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;
		styleElement = singletonElement || (singletonElement = createStyleElement(options));
		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
	} else if(obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function") {
		styleElement = createLinkElement(options);
		update = updateLink.bind(null, styleElement, options);
		remove = function() {
			removeStyleElement(styleElement);
			if(styleElement.href)
				URL.revokeObjectURL(styleElement.href);
		};
	} else {
		styleElement = createStyleElement(options);
		update = applyToTag.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
		};
	}

	update(obj);

	return function updateStyle(newObj) {
		if(newObj) {
			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
				return;
			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;
		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag(styleElement, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (styleElement.styleSheet) {
		styleElement.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = styleElement.childNodes;
		if (childNodes[index]) styleElement.removeChild(childNodes[index]);
		if (childNodes.length) {
			styleElement.insertBefore(cssNode, childNodes[index]);
		} else {
			styleElement.appendChild(cssNode);
		}
	}
}

function applyToTag(styleElement, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		styleElement.setAttribute("media", media)
	}

	if(styleElement.styleSheet) {
		styleElement.styleSheet.cssText = css;
	} else {
		while(styleElement.firstChild) {
			styleElement.removeChild(styleElement.firstChild);
		}
		styleElement.appendChild(document.createTextNode(css));
	}
}

function updateLink(linkElement, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/* If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
	and there is no publicPath defined then lets turn convertToAbsoluteUrls
	on by default.  Otherwise default to the convertToAbsoluteUrls option
	directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls){
		css = fixUrls(css);
	}

	if(sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = linkElement.href;

	linkElement.href = URL.createObjectURL(blob);

	if(oldSrc)
		URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 9 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ })
/******/ ]);